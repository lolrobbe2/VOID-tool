@using FoxholeBot.types
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using System.Globalization

<div class="wind-dial"
     style="position:absolute; bottom:@($"{BottomOffset}%"); left:@($"{LeftOffset}%"); width:@($"{Size}rem"); height:@($"{Size}rem");">
    @foreach (CompassPoint point in CompassPoints)
    {
        double rad = (point.RenderAngle - 90.0) * Math.PI / 180.0;
        double r = Size * 0.35;
        double center = Size / 2.0;
        double x = center + r * Math.Cos(rad);
        double y = center + r * Math.Sin(rad);
        double pointSize = PointSizeRem;
        double left = x - (pointSize / 2.0);
        double top = y - (pointSize / 2.0);

            <div class="compass-point @(Direction == point.Direction ? "active" : "")"
                 style="position: absolute;
                    left:@(left.ToString("F3", CultureInfo.InvariantCulture))rem;
                    top:@(top.ToString("F3", CultureInfo.InvariantCulture))rem;
                    width:@(pointSize.ToString("F3", CultureInfo.InvariantCulture))rem;
                    height:@(pointSize.ToString("F3", CultureInfo.InvariantCulture))rem;"
                 @onclick="() => HandleClick(point.Direction)"
                 role="button"
                 aria-label="@($"Select {point.Label}")">
                <span class="compass-label">@point.Label</span>
            </div>
    }

    <!-- SVG arrow overlay (pointer-events:none so it doesn't block clicks on points) -->
    <svg class="compass-svg"
         width="100%"
         height="100%"
         viewBox="0 0 @(Size.ToString(CultureInfo.InvariantCulture)) @(Size.ToString(CultureInfo.InvariantCulture))"
         style="position:absolute; top:0; left:0; pointer-events:none;"
         xmlns="http://www.w3.org/2000/svg">
        <line x1="@( (Size / 2.0).ToString("F3", CultureInfo.InvariantCulture))"
              y1="@( (Size / 2.0).ToString("F3", CultureInfo.InvariantCulture))"
              x2="@(ComputeArrowX(Size).ToString("F3", CultureInfo.InvariantCulture))"
              y2="@(ComputeArrowY(Size).ToString("F3", CultureInfo.InvariantCulture))"
              stroke="lime"
              stroke-width="0.25"
              stroke-linecap="round" />
    </svg>
</div>

@code {
    [Parameter] public EventCallback<WindDirection> OnChange { get; set; }
    [Parameter] public double Size { get; set; } = 8.0; // rem
    [Parameter] public double LeftOffset { get; set; } = 30; // rem
    [Parameter] public double BottomOffset { get; set; } = 80; // rem

    private WindDirection Direction { get; set; } = 0;

    // point diameter in rem
    private double PointSizeRem { get; } = 2.0;

    private record CompassPoint(string Label, WindDirection Direction, int RenderAngle);

    private static readonly CompassPoint[] CompassPoints = new[]
    {
        new CompassPoint("N", WindDirection.N, 0),
        new CompassPoint("NE", WindDirection.NE, 45),
        new CompassPoint("E", WindDirection.E, 90),
        new CompassPoint("SE", WindDirection.SE, 135),
        new CompassPoint("S", WindDirection.S, 180),
        new CompassPoint("SW", WindDirection.SW, 225),
        new CompassPoint("W", WindDirection.W, 270),
        new CompassPoint("NW", WindDirection.NW, 315),
    };

    private async Task HandleClick(WindDirection angle)
    {
        Direction = angle;
        if (OnChange.HasDelegate)
        {
            await OnChange.InvokeAsync(angle);
        }
    }

    // Arrow endpoint calculations (no CSS transform — coordinates computed here)
    private double ComputeArrowX(double size)
    {
        double center = size / 2.0;
        double rArrow = size * 0.3;
        double renderAngle = (360.0 - (double)Direction) % 360.0;
        double rad = (renderAngle - 90.0) * Math.PI / 180.0;
        double x = center + rArrow * Math.Cos(rad);
        return x;
    }

    private double ComputeArrowY(double size)
    {
        double center = size / 2.0;
        double rArrow = size * 0.3;
        double renderAngle = (360.0 - (double)Direction) % 360.0;
        double rad = (renderAngle - 90.0) * Math.PI / 180.0;
        double y = center + rArrow * Math.Sin(rad);
        return y;
    }
}
